// add_indexes.js

// Connect to the database
const db = connect('mongodb://your_mongo_db_url');

// Define the collections
const limitCollection = db.getCollection('limit');
const dealCollection = db.getCollection('deal');

// Add indexes to the 'limit' collection
limitCollection.createIndex({ field1: 1 }, { name: 'field1_index' });
limitCollection.createIndex({ field2: -1 }, { name: 'field2_desc_index' });

// Add indexes to the 'deal' collection
dealCollection.createIndex({ field3: 1 }, { name: 'field3_index' });
dealCollection.createIndex({ field4: -1, field5: 1 }, { name: 'compound_index' });

print('Indexes added successfully.');


// rollback_indexes.js

// Connect to the database
const db = connect('mongodb://your_mongo_db_url');

// Define the collections
const limitCollection = db.getCollection('limit');
const dealCollection = db.getCollection('deal');

// Remove indexes from the 'limit' collection
limitCollection.dropIndex('field1_index');
limitCollection.dropIndex('field2_desc_index');

// Remove indexes from the 'deal' collection
dealCollection.dropIndex('field3_index');
dealCollection.dropIndex('compound_index');

print('Indexes removed successfully.');


// add_indexes.js

// Connect to the database
const db = connect('mongodb://your_mongo_db_url');

// Define the collections
const limitCollection = db.getCollection('limit');
const dealCollection = db.getCollection('deal');

// Add compound indexes to the 'limit' collection
limitCollection.createIndex({ field1: 1, field2: 1 }, { name: 'field1_field2_compound_index' });

// Add compound indexes to the 'deal' collection
dealCollection.createIndex({ field3: 1, field4: 1 }, { name: 'field3_field4_compound_index' });

print('Compound indexes added successfully.');


// rollback_indexes.js

// Connect to the database
const db = connect('mongodb://your_mongo_db_url');

// Define the collections
const limitCollection = db.getCollection('limit');
const dealCollection = db.getCollection('deal');

// Remove compound indexes from the 'limit' collection
limitCollection.dropIndex('field1_field2_compound_index');

// Remove compound indexes from the 'deal' collection
dealCollection.dropIndex('field3_field4_compound_index');

print('Compound indexes removed successfully.');


(?i)\\bFROM\\b.*?(?=\\s+ORDER\\s+BY\\s+|$)


import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.Consumer;

import org.apache.commons.lang3.mutable.MutableInt;

public class YourClass {
    
    // Assuming you have this method to get the ResultSet
    public ResultSet getResultSet(QueryConfig queryConfig) {
        // Your implementation to get the ResultSet
        return pgDataSource.getSource().query(queryConfig.getRawQuery());
    }

    // New method to perform the asynchronous query and update CSV
    public CompletableFuture<Void> executeAsyncQueryWithCustomResultSet(final QueryConfig queryConfig, final Consumer<ResultSet> resultSetConsumer, final Executor executor) {
        checkNotNull(resultSetConsumer, "consumer is null");
        checkNotNull(executor, "executor is null");
        checkNotNull(queryConfig, "queryConfig is null");

        return CompletableFuture.runAsync(() -> {
            try (ResultSet resultSet = getResultSet(queryConfig)) {
                resultSetConsumer.accept(resultSet);
            } catch (final Exception e) {
                Logger.warn("Failed to execute query, can be ignored if interrupted [name={}, raw={}]", queryConfig.getStreamName(), queryConfig.getRawQuery(), e);
            }
        }, executor);
    }

    public void exportToCsv(QueryConfig queryConfig, Executor executor) {
        final MutableInt total = new MutableInt();

        CompletableFuture<Void> voidCompletableFuture = executeAsyncQueryWithCustomResultSet(queryConfig, rs -> {
            try {
                total.setValue(getTotalCountFromResultSet(rs));
                // Use rs to populate your CSV data here if needed
            } catch (SQLException e) {
                Logger.error("Error processing ResultSet", e);
            }
        }, executor);

        voidCompletableFuture.whenComplete((unused, throwable) -> {
            if (throwable == null) {
                csvExport
                    .fileName("test.csv")
                    .query(queryConfig.getRawQuery())
                    .columns(getColumnsFromQueryConfig(queryConfig))
                    .numOfRows(total.intValue())
                    .trigger();
            } else {
                Logger.error("Error executing async query", throwable);
            }
        });
    }

    private int getTotalCountFromResultSet(ResultSet rs) throws SQLException {
        int totalCount = 0;
        while (rs.next()) {
            totalCount++;
        }
        return totalCount;
    }

    private String[] getColumnsFromQueryConfig(QueryConfig queryConfig) {
        // Implement this method to extract column names from queryConfig
        return new String[] { "column1", "column2", "column3" }; // Example columns
    }
}


public List<ListItem<?>> filterListItemsByValues(List<ListItem<?>> originalList, List<String> filterValues) {
    return originalList.stream()
        .map(item -> {
            if (item.getValue() instanceof List) {
                List<?> subItems = (List<?>) item.getValue();
                List<ListItem<?>> filteredSubItems = subItems.stream()
                    .filter(subItem -> subItem instanceof ListItem && filterValues.contains(((ListItem<?>) subItem).getValue()))
                    .map(subItem -> (ListItem<?>) subItem)
                    .collect(Collectors.toList());

                if (!filteredSubItems.isEmpty()) {
                    return ListItem.builder()
                        .label(item.getLabel())
                        .value(filteredSubItems)
                        .build();
                }
            }
            return null;
        })
        .filter(Objects::nonNull)
        .collect(Collectors.toList());
}




import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

class ListUtilsTest {

    @Test
    void testFilterListItemsByValuesWithReverseFalse() {
        // Create sample data
        ListItem<String> subItem1 = ListItem.<String>builder().label("subItem1").value("value1").build();
        ListItem<String> subItem2 = ListItem.<String>builder().label("subItem2").value("value2").build();
        ListItem<String> subItem3 = ListItem.<String>builder().label("subItem3").value("value3").build();

        List<ListItem<?>> originalList = Arrays.asList(
            ListItem.<List<ListItem<?>>>builder()
                .label("item1")
                .value(Arrays.asList(subItem1, subItem2))
                .build(),
            ListItem.<List<ListItem<?>>>builder()
                .label("item2")
                .value(Collections.singletonList(subItem3))
                .build()
        );

        List<String> filterValues = Arrays.asList("value1");

        // Execute the method with reverse = false (include values)
        List<ListItem<?>> result = filterListItemsByValues(originalList, filterValues, false);

        // Verify the result
        assertEquals(2, result.size());

        ListItem<?> item1 = result.get(0);
        assertEquals("item1", item1.getLabel());
        List<?> item1Value = (List<?>) item1.getValue();
        assertEquals(1, item1Value.size());
        assertEquals("value1", ((ListItem<?>) item1Value.get(0)).getValue());

        ListItem<?> item2 = result.get(1);
        assertEquals("item2", item2.getLabel());
        List<?> item2Value = (List<?>) item2.getValue();
        assertEquals(0, item2Value.size());
    }

    @Test
    void testFilterListItemsByValuesWithReverseTrue() {
        // Create sample data
        ListItem<String> subItem1 = ListItem.<String>builder().label("subItem1").value("value1").build();
        ListItem<String> subItem2 = ListItem.<String>builder().label("subItem2").value("value2").build();
        ListItem<String> subItem3 = ListItem.<String>builder().label("subItem3").value("value3").build();

        List<ListItem<?>> originalList = Arrays.asList(
            ListItem.<List<ListItem<?>>>builder()
                .label("item1")
                .value(Arrays.asList(subItem1, subItem2))
                .build(),
            ListItem.<List<ListItem<?>>>builder()
                .label("item2")
                .value(Collections.singletonList(subItem3))
                .build()
        );

        List<String> filterValues = Arrays.asList("value1");

        // Execute the method with reverse = true (exclude values)
        List<ListItem<?>> result = filterListItemsByValues(originalList, filterValues, true);

        // Verify the result
        assertEquals(2, result.size());

        ListItem<?> item1 = result.get(0);
        assertEquals("item1", item1.getLabel());
        List<?> item1Value = (List<?>) item1.getValue();
        assertEquals(1, item1Value.size());
        assertEquals("value2", ((ListItem<?>) item1Value.get(0)).getValue());

        ListItem<?> item2 = result.get(1);
        assertEquals("item2", item2.getLabel());
        List<?> item2Value = (List<?>) item2.getValue();
        assertEquals(1, item2Value.size());
        assertEquals("value3", ((ListItem<?>) item2Value.get(0)).getValue());
    }
}



.filter(subItem -> {
                        String value = ((ListItem<?>) subItem).getValue();
                        return reverse ? !filterValues.contains(value) : filterValues.contains(value);
                    })
                    .map(subItem -> (ListItem<?>) subItem)
                    .collect(Collectors.toList());

