import java.sql.ResultSet;

public interface QueryClient {
    ResultSet resultof();
    ResultSet resultofRange(int offset, int limit);
    int total();
}


import java.sql.ResultSet;

public class QueryClientImpl implements QueryClient {
    private final ResultSetService resultSetService;
    private final String queryId;

    public QueryClientImpl(ResultSetService resultSetService, QueryConfig queryConfig) {
        this.resultSetService = resultSetService;
        this.queryId = resultSetService.executeQuery(queryConfig);
        if (this.queryId == null) {
            throw new IllegalStateException("Failed to execute query and initialize client.");
        }
    }

    @Override
    public ResultSet resultof() {
        return resultSetService.resultof(queryId);
    }

    @Override
    public ResultSet resultofRange(int offset, int limit) {
        return resultSetService.resultofRange(queryId, offset, limit);
    }

    @Override
    public int total() {
        return resultSetService.total(queryId);
    }
}



import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

import java.sql.ResultSet;
import java.util.concurrent.TimeUnit;

public class ResultSetService {
    private final LoadingCache<String, ResultSet> cache;
    private final PgDataSource pgDataSource = new PgDataSource();
    private final QueryBuilder queryBuilder = new QueryBuilder();
    private final QueryConfigStore queryConfigStore = new QueryConfigStore();

    public ResultSetService() {
        this.cache = CacheBuilder.newBuilder()
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .build(new CacheLoader<String, ResultSet>() {
                    @Override
                    public ResultSet load(String queryId) throws Exception {
                        QueryConfig queryConfig = queryConfigStore.getQueryConfigById(queryId);
                        if (queryConfig == null) {
                            throw new IllegalArgumentException("Invalid query ID");
                        }
                        return executeQueryInternal(queryConfig);
                    }
                });
    }

    public ResultSet resultof(String id) {
        return cache.getUnchecked(id);
    }

    public ResultSet resultofRange(String id, int offset, int limit) {
        ResultSet resultSet = cache.getUnchecked(id);
        if (resultSet == null) {
            return null;
        }
        return extractRange(resultSet, offset, limit);
    }

    public int total(String id) {
        ResultSet resultSet = cache.getUnchecked(id);
        if (resultSet == null) {
            return 0;
        }
        return calculateTotal(resultSet);
    }

    public String executeQuery(QueryConfig queryConfig) {
        try {
            String queryId = generateQueryId(queryConfig);
            queryConfigStore.saveQueryConfig(queryId, queryConfig);
            cache.put(queryId, executeQueryInternal(queryConfig));
            return queryId;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private ResultSet executeQueryInternal(QueryConfig queryConfig) throws Exception {
        String sqlQuery = queryBuilder.buildQuery(queryConfig);
        return pgDataSource.getSource().query(sqlQuery);
    }

    private String generateQueryId(QueryConfig queryConfig) {
        return Integer.toHexString(queryConfig.hashCode());
    }

    private ResultSet extractRange(ResultSet resultSet, int offset, int limit) {
        try {
            resultSet.absolute(offset);
            // Extract the limited rows and return a new ResultSet
            // Placeholder implementation; actual logic needed
        } catch (Exception e) {
            e.printStackTrace();
        }
        return resultSet;
    }

    private int calculateTotal(ResultSet resultSet) {
        try {
            resultSet.last();
            return resultSet.getRow();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0;
    }
}



import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class QueryConfigStore {
    private final ConcurrentMap<String, QueryConfig> queryConfigMap = new ConcurrentHashMap<>();

    public void saveQueryConfig(String queryId, QueryConfig queryConfig) {
        queryConfigMap.put(queryId, queryConfig);
    }

    public QueryConfig getQueryConfigById(String queryId) {
        return queryConfigMap.get(queryId);
    }
}




public enum DecimalType {
    DOUBLE,
    FLOAT,
    BIGDECIMAL;

    public static boolean isDecimalType(String type) {
        try {
            return Enum.valueOf(DecimalType.class, type.toUpperCase()) != null;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}

public class Main {

    // Dummy Field class for demonstration purposes
    static class Field {
        private String type;

        public Field(String type) {
            this.type = type;
        }

        public String getType() {
            return type;
        }
    }

    protected boolean isDecimal(final Field f) {
        return DecimalType.isDecimalType(f.getType().toLowerCase());
    }

    public static void main(String[] args) {
        Main main = new Main();
        
        Field field1 = new Field("double");
        Field field2 = new Field("int");
        
        System.out.println(main.isDecimal(field1)); // Output: true
        System.out.println(main.isDecimal(field2)); // Output: false
    }
}



import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

public class DecimalTypeTest {

    @Test
    public void testIsDecimalType_Double() {
        assertTrue(DecimalType.isDecimalType("double"));
    }

    @Test
    public void testIsDecimalType_Float() {
        assertTrue(DecimalType.isDecimalType("float"));
    }

    @Test
    public void testIsDecimalType_BigDecimal() {
        assertTrue(DecimalType.isDecimalType("bigdecimal"));
    }

    @Test
    public void testIsDecimalType_InvalidType() {
        assertFalse(DecimalType.isDecimalType("int"));
    }

    @Test
    public void testIsDecimalType_EmptyString() {
        assertFalse(DecimalType.isDecimalType(""));
    }

    @Test
    public void testIsDecimalType_Null() {
        assertFalse(DecimalType.isDecimalType(null));
    }
}



import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Database connection details
        String url = "jdbc:postgresql://localhost:5432/your_database";
        String user = "your_username";
        String password = "your_password";

        // List of table/view names
        List<String> tableNames = Arrays.asList("view1", "table1", "view2", "table2");

        // Base query template
        String queryTemplate = "SELECT table_name, column_name, data_type " +
                               "FROM information_schema.columns " +
                               "WHERE table_name IN (%s) AND table_schema = 'public'";

        // Join table names into a comma-separated string wrapped in single quotes
        String tableNamesString = tableNames.stream()
                                            .map(name -> "'" + name + "'")
                                            .collect(Collectors.joining(", "));

        // Format the query with the table names
        String query = String.format(queryTemplate, tableNamesString);

        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            while (rs.next()) {
                String table = rs.getString("table_name");
                String columnName = rs.getString("column_name");
                String dataType = rs.getString("data_type");
                System.out.println("Column: " + table + "." + columnName + " Data Type: " + dataType);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

